{
  "version": 3,
  "sources": ["..\\doublearray.ts"],
  "sourcesContent": [
    "// Copyright (c) 2014 Takuya Asano All Rights Reserved.\r\n\r\n/*\r\n *\r\n * rewrite by @f1w3_ | 2024\r\n * All rights reserved by Takuya Asano.\r\n * See above for more information.\r\n *  \r\n */\r\n\r\n\"use strict\";\r\n\r\nconst TERM_CHAR = \"\\u0000\"; // terminal character\r\nconst TERM_CODE = 0;        // terminal character code\r\nconst ROOT_ID = 0;          // index of root node\r\nconst NOT_FOUND = -1;       // traverse() returns if no nodes found\r\nconst BASE_SIGNED = true;\r\nconst CHECK_SIGNED = true;\r\nconst BASE_BYTES = 4;\r\nconst CHECK_BYTES = 4;\r\nconst MEMORY_EXPAND_RATIO = 2;\r\n\r\n// Array utility functions\r\nconst newArrayBuffer = (signed: boolean, bytes: number, size: number) => {\r\n    if (signed) {\r\n        switch (bytes) {\r\n            case 1:\r\n                return new Int8Array(size);\r\n            case 2:\r\n                return new Int16Array(size);\r\n            case 4:\r\n                return new Int32Array(size);\r\n            default:\r\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\r\n        }\r\n    } else {\r\n        switch (bytes) {\r\n            case 1:\r\n                return new Uint8Array(size);\r\n            case 2:\r\n                return new Uint16Array(size);\r\n            case 4:\r\n                return new Uint32Array(size);\r\n            default:\r\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\r\n        }\r\n    }\r\n};\r\n\r\nconst arrayCopy = (src: Uint8Array, src_offset: number, length: number) => {\r\n    var buffer = new ArrayBuffer(length);\r\n    var dstU8 = new Uint8Array(buffer, 0, length);\r\n    var srcU8 = src.subarray(src_offset, length);\r\n    dstU8.set(srcU8);\r\n    return dstU8;\r\n};\r\n\r\n/**\r\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\r\n *\r\n * @param {String} str UTF-16 string to convert\r\n * @return {Uint8Array | null} Byte sequence encoded by UTF-8\r\n */\r\nconst stringToUtf8Bytes = (str: string): Uint8Array | null => {\r\n    const bytes = new Uint8Array(str.length * 4);\r\n    let j = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let unicode_code = str.charCodeAt(i);\r\n        if (unicode_code >= 0xD800 && unicode_code <= 0xDBFF) {\r\n            // surrogate pair\r\n            if (i + 1 < str.length) {\r\n                const lower = str.charCodeAt(++i);\r\n                if (lower >= 0xDC00 && lower <= 0xDFFF) {\r\n                    unicode_code = ((unicode_code - 0xD800) << 10) + (lower - 0xDC00) + 0x10000;\r\n                } else {\r\n                    return null; // malformed surrogate pair\r\n                }\r\n            } else {\r\n                return null; // malformed surrogate pair at end of string\r\n            }\r\n        }\r\n\r\n        if (unicode_code < 0x80) {\r\n            bytes[j++] = unicode_code;\r\n        } else if (unicode_code < 0x800) {\r\n            bytes[j++] = 0xC0 | (unicode_code >>> 6);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else if (unicode_code < 0x10000) {\r\n            bytes[j++] = 0xE0 | (unicode_code >>> 12);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 6) & 0x3F);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else if (unicode_code < 0x110000) {\r\n            bytes[j++] = 0xF0 | (unicode_code >>> 18);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 12) & 0x3F);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 6) & 0x3F);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else {\r\n            return null; // malformed UCS4 code\r\n        }\r\n    }\r\n\r\n    return bytes.subarray(0, j);\r\n};\r\n\r\n/**\r\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\r\n *\r\n * @param {Uint8Array} bytes UTF-8 byte sequence to convert\r\n * @return {String} String encoded by UTF-16\r\n */\r\nconst utf8BytesToString = (bytes: Uint8Array): string => {\r\n    const strArray = [];\r\n    let i = 0;\r\n\r\n    while (i < bytes.length) {\r\n        const b1 = bytes[i++];\r\n        let code;\r\n\r\n        if (b1 < 0x80) {\r\n            // 1 byte\r\n            code = b1;\r\n        } else if ((b1 >> 5) === 0x06) {\r\n            // 2 bytes\r\n            const b2 = bytes[i++];\r\n            code = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\r\n        } else if ((b1 >> 4) === 0x0e) {\r\n            // 3 bytes\r\n            const b2 = bytes[i++];\r\n            const b3 = bytes[i++];\r\n            code = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\r\n        } else {\r\n            // 4 bytes\r\n            const b2 = bytes[i++];\r\n            const b3 = bytes[i++];\r\n            const b4 = bytes[i++];\r\n            code = ((b1 & 0x07) << 18) | ((b2 & 0x3f) << 12) | ((b3 & 0x3f) << 6) | (b4 & 0x3f);\r\n        }\r\n\r\n        if (code < 0x10000) {\r\n            strArray.push(String.fromCharCode(code));\r\n        } else {\r\n            // surrogate pair\r\n            code -= 0x10000;\r\n            strArray.push(String.fromCharCode(0xD800 | (code >> 10)));\r\n            strArray.push(String.fromCharCode(0xDC00 | (code & 0x3FF)));\r\n        }\r\n    }\r\n\r\n    return strArray.join('');\r\n};\r\n\r\ntype ArrayBuffer = Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array;\r\n\r\ntype BaseCheck = {\r\n    signed: boolean,\r\n    bytes: number,\r\n    array: ArrayBuffer | null\r\n};\r\n\r\nconst newBC = (initial_size: number = 1024) => {\r\n    const initBase = (_base: ArrayBuffer, start: number, end: number) => {  // 'end' index does not include\r\n        if (!check.array) {\r\n            throw new Error(\"check array is not initialized\");\r\n        }\r\n        for (let i = start; i < end; i++) {\r\n            _base[i] = - i + 1;  // inversed previous empty node index\r\n        }\r\n        if (0 < check.array[check.array.length - 1]) {\r\n            let last_used_id = check.array.length - 2;\r\n            while (0 < check.array[last_used_id]) {\r\n                last_used_id--;\r\n            }\r\n            _base[start] = - last_used_id;\r\n        }\r\n    };\r\n\r\n    const initCheck = (_check: ArrayBuffer, start: number, end: number) => {\r\n        for (let i = start; i < end; i++) {\r\n            _check[i] = - i - 1;  // inversed next empty node index\r\n        }\r\n    };\r\n\r\n    const realloc = (min_size: number) => {\r\n        // expand arrays size by given ratio\r\n        const new_size = min_size * MEMORY_EXPAND_RATIO;\r\n        // console.log('re-allocate memory to ' + new_size);\r\n\r\n        const base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\r\n        if (!base.array) throw new Error('realloc failed. base.array is null');\r\n        initBase(base_new_array, base.array.length, new_size);  // init BASE in new range\r\n        base_new_array.set(base.array);\r\n        base.array = null;  // explicit GC\r\n        base.array = base_new_array;\r\n\r\n        const check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\r\n        if (!check.array) throw new Error('realloc failed. check.array is null');\r\n        initCheck(check_new_array, check.array.length, new_size);  // init CHECK in new range\r\n        check_new_array.set(check.array);\r\n        check.array = null;  // explicit GC\r\n        check.array = check_new_array;\r\n    };\r\n\r\n    let first_unused_node = ROOT_ID + 1;\r\n\r\n    const base: BaseCheck = {\r\n        signed: BASE_SIGNED,\r\n        bytes: BASE_BYTES,\r\n        array: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size)\r\n    };\r\n\r\n    const check: BaseCheck = {\r\n        signed: CHECK_SIGNED,\r\n        bytes: CHECK_BYTES,\r\n        array: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size)\r\n    };\r\n\r\n    // init root node\r\n    if (!base.array) {\r\n        throw new Error(\"base.array is null\");\r\n    }\r\n    if (!check.array) {\r\n        throw new Error(\"check.array is null\");\r\n    }\r\n    base.array[ROOT_ID] = 1;\r\n    check.array[ROOT_ID] = ROOT_ID;\r\n\r\n    // init BASE\r\n    initBase(base.array, ROOT_ID + 1, base.array.length);\r\n\r\n    // init CHECK\r\n    initCheck(check.array, ROOT_ID + 1, check.array.length);\r\n\r\n    return {\r\n        getBaseBuffer: () => {\r\n            return base.array;\r\n        },\r\n        getCheckBuffer: () => {\r\n            return check.array;\r\n        },\r\n        loadBaseBuffer: (base_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n            base.array = base_buffer;\r\n            return this;\r\n        },\r\n        loadCheckBuffer: (check_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n            check.array = check_buffer;\r\n            return this;\r\n        },\r\n        size: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            return Math.max(base.array.length, check.array.length);\r\n        },\r\n        getBase: (index: number) => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (base.array.length - 1 < index) {\r\n                return - index + 1;\r\n                // realloc(index);\r\n            }\r\n            // if (!Number.isFinite(base.array[index])) {\r\n            //     console.log('getBase:' + index);\r\n            //     throw 'getBase' + index;\r\n            // }\r\n            return base.array[index];\r\n        },\r\n        getCheck: (index: number) => {\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            if (check.array.length - 1 < index) {\r\n                return - index - 1;\r\n                // realloc(index);\r\n            }\r\n            // if (!Number.isFinite(check.array[index])) {\r\n            //     console.log('getCheck:' + index);\r\n            //     throw 'getCheck' + index;\r\n            // }\r\n            return check.array[index];\r\n        },\r\n        setBase: (index: number, base_value: number) => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (base.array.length - 1 < index) {\r\n                realloc(index);\r\n            }\r\n            base.array[index] = base_value;\r\n        },\r\n        setCheck: (index: number, check_value: number) => {\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            if (check.array.length - 1 < index) {\r\n                realloc(index);\r\n            }\r\n            check.array[index] = check_value;\r\n        },\r\n        setFirstUnusedNode: (index: number) => {\r\n            // if (!Number.isFinite(index)) {\r\n            //     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\r\n            // }\r\n            first_unused_node = index;\r\n        },\r\n        getFirstUnusedNode: function () {\r\n            // if (!Number.isFinite(first_unused_node)) {\r\n            //     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\r\n            // }\r\n            return first_unused_node;\r\n        },\r\n        shrink: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            let last_index = Math.max(base.array.length, check.array.length); - 1;\r\n            while (true) {\r\n                if (0 <= check.array[last_index]) {\r\n                    break;\r\n                }\r\n                last_index--;\r\n            }\r\n            base.array = base.array.subarray(0, last_index + 2);   // keep last unused node\r\n            check.array = check.array.subarray(0, last_index + 2); // keep last unused node\r\n        },\r\n        calc: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            let unused_count = 0;\r\n            const size = check.array.length;\r\n            for (let i = 0; i < size; i++) {\r\n                if (check.array[i] < 0) {\r\n                    unused_count++;\r\n                }\r\n            }\r\n            return {\r\n                all: size,\r\n                unused: unused_count,\r\n                efficiency: (size - unused_count) / size\r\n            };\r\n        },\r\n        dump: () => {\r\n            // for debug\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n\r\n            let dump_base = \"\";\r\n            let dump_check = \"\";\r\n\r\n            for (const data of base.array) {\r\n                dump_base = dump_base + \" \" + data;\r\n            }\r\n            for (const data of check.array) {\r\n                dump_check = dump_check + \" \" + data;\r\n            }\r\n            console.log(\"base:\" + dump_base);\r\n            console.log(\"chck:\" + dump_check);\r\n\r\n            return \"base:\" + dump_base + \" chck:\" + dump_check;\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Factory method of double array\r\n */\r\nclass DoubleArrayBuilder {\r\n    bc: ReturnType<typeof newBC>;\r\n    keys: { k: string, v: number }[]\r\n    constructor(initial_size: number = 1024) {\r\n        this.bc = newBC(initial_size);  // BASE and CHECK\r\n        this.keys = [];\r\n    }\r\n\r\n    /**\r\n    * Append a key to initialize set\r\n    * (This method should be called by dictionary ordered key)\r\n    *\r\n    * @param {String} key\r\n    * @param {Number} value Integer value from 0 to max signed integer number - 1\r\n    */\r\n    append(key: string, record: number) {\r\n        this.keys.push({ k: key, v: record });\r\n        return this;\r\n    };\r\n\r\n    /**\r\n    * Build double array for given keys\r\n    *\r\n    * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\r\n    * 'k' is a key string, 'v' is a record assigned to that key.\r\n    * @return {DoubleArray} Compiled double array\r\n    */\r\n    build(keys: { k: string, v: number }[] = this.keys, sorted: boolean = false) {\r\n        if (keys == null) {\r\n            return new DoubleArray(this.bc);\r\n        }\r\n        // Convert key string to ArrayBuffer\r\n        let buff_keys: { k: any; v: number; }[] | null = keys.map((k) => {\r\n            return {\r\n                k: stringToUtf8Bytes(k.k + TERM_CHAR),\r\n                v: k.v\r\n            };\r\n        });\r\n\r\n        // Sort keys by byte order\r\n        if (sorted) {\r\n            this.keys = buff_keys;\r\n        } else {\r\n            this.keys = buff_keys.sort((k1, k2) => {\r\n                const b1 = k1.k;\r\n                const b2 = k2.k;\r\n                const min_length = Math.min(b1.length, b2.length);\r\n                for (let pos = 0; pos < min_length; pos++) {\r\n                    if (b1[pos] === b2[pos]) {\r\n                        continue;\r\n                    }\r\n                    return b1[pos] - b2[pos];\r\n                }\r\n                return b1.length - b2.length;\r\n            });\r\n        }\r\n\r\n        buff_keys = null;  // explicit GC\r\n\r\n        this._build(ROOT_ID, 0, 0, this.keys.length);\r\n        return new DoubleArray(this.bc);\r\n    };\r\n\r\n    /**\r\n    * Append nodes to BASE and CHECK array recursively\r\n    */\r\n    _build(parent_index: number, position: number, start: number, length: number) {\r\n        const children_info = this.getChildrenInfo(position, start, length);\r\n        const _base = this.findAllocatableBase(children_info);\r\n\r\n        this.setBC(parent_index, children_info, _base);\r\n\r\n        let i = 0\r\n        for (const child_code of children_info) {\r\n            if (child_code === TERM_CODE) {\r\n                continue;\r\n            }\r\n            const child_start = children_info[i + 1];\r\n            const child_len = children_info[i + 2];\r\n            const child_index = _base + child_code;\r\n            this._build(child_index, position + 1, child_start, child_len);\r\n            i = i + 1;\r\n        }\r\n    };\r\n\r\n    getChildrenInfo(position: number, start: number, length: number) {\r\n        let current_char = this.keys[start].k[position];\r\n        let children_info = new Int32Array(length * 3);\r\n        let i = 0;\r\n\r\n        children_info[i++] = parseInt(current_char);  // char (current)\r\n        children_info[i++] = start;         // start index (current)\r\n\r\n        let next_pos = start;\r\n        let start_pos = start;\r\n        for (; next_pos < start + length; next_pos++) {\r\n            const next_char = this.keys[next_pos].k[position];\r\n            if (current_char !== next_char) {\r\n                children_info[i++] = next_pos - start_pos;  // length (current)\r\n\r\n                children_info[i++] = parseInt(next_char);             // char (next)\r\n                children_info[i++] = next_pos;              // start index (next)\r\n                current_char = next_char;\r\n                start_pos = next_pos;\r\n            }\r\n        }\r\n        children_info[i++] = next_pos - start_pos;\r\n        children_info = children_info.subarray(0, i);\r\n\r\n        return children_info;\r\n    };\r\n\r\n    setBC(parent_id: number, children_info: Int32Array, _base: number) {\r\n        const bc = this.bc;\r\n        bc.setBase(parent_id, _base);  // Update BASE of parent node\r\n        let i = 0;\r\n        for (const code of children_info) {\r\n            const child_id = _base + code;\r\n            // Update linked list of unused nodes\r\n\r\n            // Assertion\r\n            // if (child_id < 0) {\r\n            //     throw 'assertion error: child_id is negative'\r\n            // }\r\n\r\n            const prev_unused_id = - bc.getBase(child_id);\r\n            const next_unused_id = - bc.getCheck(child_id);\r\n            // if (prev_unused_id < 0) {\r\n            //     throw 'assertion error: setBC'\r\n            // }\r\n            // if (next_unused_id < 0) {\r\n            //     throw 'assertion error: setBC'\r\n            // }\r\n            if (child_id !== bc.getFirstUnusedNode()) {\r\n                bc.setCheck(prev_unused_id, - next_unused_id);\r\n            } else {\r\n                // Update first_unused_node\r\n                bc.setFirstUnusedNode(next_unused_id);\r\n            }\r\n            bc.setBase(next_unused_id, - prev_unused_id);\r\n\r\n            const check = parent_id;         // CHECK is parent node index\r\n            bc.setCheck(child_id, check);  // Update CHECK of child node\r\n\r\n            // Update record\r\n            if (code === TERM_CODE) {\r\n                const start_pos = children_info[i + 1];\r\n                // var len = children_info[i + 2];\r\n                // if (len != 1) {\r\n                //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\r\n                // }\r\n                let value = this.keys[start_pos].v;\r\n\r\n                if (value == null) {\r\n                    value = 0;\r\n                }\r\n\r\n                const base = - value - 1;       // BASE is inverted record value\r\n                bc.setBase(child_id, base);  // Update BASE of child(leaf) node\r\n            }\r\n            i = i + 1;\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Find BASE value that all children are allocatable in double array's region\r\n    */\r\n    findAllocatableBase(children_info: Int32Array) {\r\n        const bc = this.bc;\r\n        // Assertion: keys are sorted by byte order\r\n        // var c = -1;\r\n        // for (var i = 0; i < children_info.length; i = i + 3) {\r\n        //     if (children_info[i] < c) {\r\n        //         throw 'assertion error: not sort key'\r\n        //     }\r\n        //     c = children_info[i];\r\n        // }\r\n\r\n        // iterate linked list of unused nodes\r\n        let _base: number;\r\n        let curr = bc.getFirstUnusedNode();  // current index\r\n        // if (curr < 0) {\r\n        //     throw 'assertion error: getFirstUnusedNode returns negative value'\r\n        // }\r\n\r\n        while (true) {\r\n            _base = curr - children_info[0];\r\n            if (_base < 0) {\r\n                curr = - bc.getCheck(curr);  // next\r\n\r\n                // if (curr < 0) {\r\n                //     throw 'assertion error: getCheck returns negative value'\r\n                // }\r\n\r\n                continue;\r\n            }\r\n\r\n            let empty_area_found = true;\r\n            for (const code of children_info) {\r\n                const candidate_id = _base + code;\r\n                if (!this.isUnusedNode(candidate_id)) {\r\n                    // candidate_id is used node\r\n                    // next\r\n                    curr = - bc.getCheck(curr);\r\n                    // if (curr < 0) {\r\n                    //     throw 'assertion error: getCheck returns negative value'\r\n                    // }\r\n                    empty_area_found = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (empty_area_found) {\r\n                // Area is free\r\n                return _base;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Check this double array index is unused or not\r\n    */\r\n    isUnusedNode(index: number) {\r\n        const bc = this.bc;\r\n        const check = bc.getCheck(index);\r\n\r\n        // if (index < 0) {\r\n        //     throw 'assertion error: isUnusedNode index:' + index;\r\n        // }\r\n\r\n        if (index === ROOT_ID) {\r\n            // root node\r\n            return false;\r\n        }\r\n        if (check < 0) {\r\n            // unused\r\n            return true;\r\n        }\r\n\r\n        // used node (incl. leaf)\r\n        return false;\r\n    };\r\n}\r\n\r\n/**\r\n* Factory method of double array\r\n*/\r\nclass DoubleArray {\r\n    bc: ReturnType<typeof newBC>;\r\n    constructor(bc: ReturnType<typeof newBC>) {\r\n        this.bc = bc;  // BASE and CHECK\r\n        this.bc.shrink();\r\n    }\r\n\r\n    /**\r\n     * Look up a given key in this trie\r\n     *\r\n     * @param {String} key\r\n     * @return {Boolean} True if this trie contains a given key\r\n     */\r\n    contain(key: string) {\r\n        const bc = this.bc;\r\n        key += TERM_CHAR;\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child === NOT_FOUND) {\r\n                return false;\r\n            }\r\n\r\n            if (bc.getBase(child) <= 0) {\r\n                // leaf node\r\n                return true;\r\n            } else {\r\n                // not leaf\r\n                parent = child;\r\n                continue;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n    * Look up a given key in this trie\r\n    *\r\n    * @param {String} key\r\n    * @return {Number} Record value assgned to this key, -1 if this key does not contain\r\n    */\r\n    lookup(key: string) {\r\n        key += TERM_CHAR;\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child === NOT_FOUND) {\r\n                return NOT_FOUND;\r\n            }\r\n            parent = child;\r\n        }\r\n        const base = this.bc.getBase(child);\r\n        if (base <= 0) {\r\n            // leaf node\r\n            return - base - 1;\r\n        } else {\r\n            // not leaf\r\n            return NOT_FOUND;\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n    * Common prefix search\r\n    *\r\n    * @param {String} key\r\n    * @return {Array} Each result object has 'k' and 'v' (key and record,\r\n    * respectively) properties assigned to matched string\r\n    */\r\n    commonPrefixSearch(key: string) {\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        const result = [];\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        let i = 0\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child !== NOT_FOUND) {\r\n                parent = child;\r\n                // look forward by terminal character code to check this node is a leaf or not\r\n                const grand_child = this.traverse(child, TERM_CODE);\r\n                if (grand_child !== NOT_FOUND) {\r\n                    const base = this.bc.getBase(grand_child);\r\n                    const r: { k: string, v: number } = { k: '', v: -1 };\r\n                    if (base <= 0) {\r\n                        // If child is a leaf node, add record to result\r\n                        r.v = - base - 1;\r\n                    }\r\n                    // If child is a leaf node, add word to result\r\n                    r.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\r\n                    result.push(r);\r\n                }\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n            i = i + 1;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    traverse(parent: number, code: number) {\r\n        const child = this.bc.getBase(parent) + code;\r\n        if (this.bc.getCheck(child) === parent) {\r\n            return child;\r\n        } else {\r\n            return NOT_FOUND;\r\n        }\r\n    };\r\n\r\n    size() {\r\n        return this.bc.size();\r\n    };\r\n\r\n    calc() {\r\n        return this.bc.calc();\r\n    };\r\n\r\n    dump() {\r\n        return this.bc.dump();\r\n    };\r\n}\r\n\r\nconst doublearray = {\r\n    builder: (initial_size: number = 1024) => {\r\n        return new DoubleArrayBuilder(initial_size);\r\n    },\r\n    load: (base_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array, check_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n        const bc = newBC(0);\r\n        bc.loadBaseBuffer(base_buffer);\r\n        bc.loadCheckBuffer(check_buffer);\r\n        return new DoubleArray(bc);\r\n    }\r\n};\r\n\r\nexport { DoubleArrayBuilder, DoubleArray };\r\n\r\nexport default doublearray;\r\n"
  ],
  "mappings": "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",
  "debugId": "4183D2E71C2FA3E664756E2164756E21",
  "names": []
}