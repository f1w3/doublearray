{
  "version": 3,
  "sources": ["..\\doublearray.ts"],
  "sourcesContent": [
    "// Copyright (c) 2014 Takuya Asano All Rights Reserved.\r\n\r\n/*\r\n *\r\n * rewrite by @f1w3_ | 2024\r\n * All rights reserved by Takuya Asano.\r\n * See above for more information.\r\n *  \r\n */\r\n\r\n\"use strict\";\r\n\r\nconst TERM_CHAR = \"\\u0000\"; // terminal character\r\nconst TERM_CODE = 0;        // terminal character code\r\nconst ROOT_ID = 0;          // index of root node\r\nconst NOT_FOUND = -1;       // traverse() returns if no nodes found\r\nconst BASE_SIGNED = true;\r\nconst CHECK_SIGNED = true;\r\nconst BASE_BYTES = 4;\r\nconst CHECK_BYTES = 4;\r\nconst MEMORY_EXPAND_RATIO = 2;\r\n\r\n// Array utility functions\r\nconst newArrayBuffer = (signed: boolean, bytes: number, size: number) => {\r\n    if (signed) {\r\n        switch (bytes) {\r\n            case 1:\r\n                return new Int8Array(size);\r\n            case 2:\r\n                return new Int16Array(size);\r\n            case 4:\r\n                return new Int32Array(size);\r\n            default:\r\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\r\n        }\r\n    } else {\r\n        switch (bytes) {\r\n            case 1:\r\n                return new Uint8Array(size);\r\n            case 2:\r\n                return new Uint16Array(size);\r\n            case 4:\r\n                return new Uint32Array(size);\r\n            default:\r\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\r\n        }\r\n    }\r\n};\r\n\r\nconst arrayCopy = (src: Uint8Array, src_offset: number, length: number) => {\r\n    var buffer = new ArrayBuffer(length);\r\n    var dstU8 = new Uint8Array(buffer, 0, length);\r\n    var srcU8 = src.subarray(src_offset, length);\r\n    dstU8.set(srcU8);\r\n    return dstU8;\r\n};\r\n\r\n/**\r\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\r\n *\r\n * @param {String} str UTF-16 string to convert\r\n * @return {Uint8Array | null} Byte sequence encoded by UTF-8\r\n */\r\nconst stringToUtf8Bytes = (str: string): Uint8Array | null => {\r\n    const bytes = new Uint8Array(str.length * 4);\r\n    let j = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let unicode_code = str.charCodeAt(i);\r\n        if (unicode_code >= 0xD800 && unicode_code <= 0xDBFF) {\r\n            // surrogate pair\r\n            if (i + 1 < str.length) {\r\n                const lower = str.charCodeAt(++i);\r\n                if (lower >= 0xDC00 && lower <= 0xDFFF) {\r\n                    unicode_code = ((unicode_code - 0xD800) << 10) + (lower - 0xDC00) + 0x10000;\r\n                } else {\r\n                    return null; // malformed surrogate pair\r\n                }\r\n            } else {\r\n                return null; // malformed surrogate pair at end of string\r\n            }\r\n        }\r\n\r\n        if (unicode_code < 0x80) {\r\n            bytes[j++] = unicode_code;\r\n        } else if (unicode_code < 0x800) {\r\n            bytes[j++] = 0xC0 | (unicode_code >>> 6);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else if (unicode_code < 0x10000) {\r\n            bytes[j++] = 0xE0 | (unicode_code >>> 12);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 6) & 0x3F);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else if (unicode_code < 0x110000) {\r\n            bytes[j++] = 0xF0 | (unicode_code >>> 18);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 12) & 0x3F);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 6) & 0x3F);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else {\r\n            return null; // malformed UCS4 code\r\n        }\r\n    }\r\n\r\n    return bytes.subarray(0, j);\r\n};\r\n\r\n/**\r\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\r\n *\r\n * @param {Uint8Array} bytes UTF-8 byte sequence to convert\r\n * @return {String} String encoded by UTF-16\r\n */\r\nconst utf8BytesToString = (bytes: Uint8Array): string => {\r\n    const strArray = [];\r\n    let i = 0;\r\n\r\n    while (i < bytes.length) {\r\n        const b1 = bytes[i++];\r\n        let code;\r\n\r\n        if (b1 < 0x80) {\r\n            // 1 byte\r\n            code = b1;\r\n        } else if ((b1 >> 5) === 0x06) {\r\n            // 2 bytes\r\n            const b2 = bytes[i++];\r\n            code = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\r\n        } else if ((b1 >> 4) === 0x0e) {\r\n            // 3 bytes\r\n            const b2 = bytes[i++];\r\n            const b3 = bytes[i++];\r\n            code = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\r\n        } else {\r\n            // 4 bytes\r\n            const b2 = bytes[i++];\r\n            const b3 = bytes[i++];\r\n            const b4 = bytes[i++];\r\n            code = ((b1 & 0x07) << 18) | ((b2 & 0x3f) << 12) | ((b3 & 0x3f) << 6) | (b4 & 0x3f);\r\n        }\r\n\r\n        if (code < 0x10000) {\r\n            strArray.push(String.fromCharCode(code));\r\n        } else {\r\n            // surrogate pair\r\n            code -= 0x10000;\r\n            strArray.push(String.fromCharCode(0xD800 | (code >> 10)));\r\n            strArray.push(String.fromCharCode(0xDC00 | (code & 0x3FF)));\r\n        }\r\n    }\r\n\r\n    return strArray.join('');\r\n};\r\n\r\ntype ArrayBuffer = Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array;\r\n\r\ntype BaseCheck = {\r\n    signed: boolean,\r\n    bytes: number,\r\n    array: ArrayBuffer | null\r\n};\r\n\r\nconst newBC = (initial_size: number = 1024) => {\r\n    const initBase = (_base: ArrayBuffer, start: number, end: number) => {  // 'end' index does not include\r\n        if (!check.array) {\r\n            throw new Error(\"check array is not initialized\");\r\n        }\r\n        for (let i = start; i < end; i++) {\r\n            _base[i] = - i + 1;  // inversed previous empty node index\r\n        }\r\n        if (0 < check.array[check.array.length - 1]) {\r\n            let last_used_id = check.array.length - 2;\r\n            while (0 < check.array[last_used_id]) {\r\n                last_used_id--;\r\n            }\r\n            _base[start] = - last_used_id;\r\n        }\r\n    };\r\n\r\n    const initCheck = (_check: ArrayBuffer, start: number, end: number) => {\r\n        for (let i = start; i < end; i++) {\r\n            _check[i] = - i - 1;  // inversed next empty node index\r\n        }\r\n    };\r\n\r\n    const realloc = (min_size: number) => {\r\n        // expand arrays size by given ratio\r\n        const new_size = min_size * MEMORY_EXPAND_RATIO;\r\n        // console.log('re-allocate memory to ' + new_size);\r\n\r\n        const base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\r\n        if (!base.array) throw new Error('realloc failed. base.array is null');\r\n        initBase(base_new_array, base.array.length, new_size);  // init BASE in new range\r\n        base_new_array.set(base.array);\r\n        base.array = null;  // explicit GC\r\n        base.array = base_new_array;\r\n\r\n        const check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\r\n        if (!check.array) throw new Error('realloc failed. check.array is null');\r\n        initCheck(check_new_array, check.array.length, new_size);  // init CHECK in new range\r\n        check_new_array.set(check.array);\r\n        check.array = null;  // explicit GC\r\n        check.array = check_new_array;\r\n    };\r\n\r\n    let first_unused_node = ROOT_ID + 1;\r\n\r\n    const base: BaseCheck = {\r\n        signed: BASE_SIGNED,\r\n        bytes: BASE_BYTES,\r\n        array: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size)\r\n    };\r\n\r\n    const check: BaseCheck = {\r\n        signed: CHECK_SIGNED,\r\n        bytes: CHECK_BYTES,\r\n        array: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size)\r\n    };\r\n\r\n    // init root node\r\n    if (!base.array) {\r\n        throw new Error(\"base.array is null\");\r\n    }\r\n    if (!check.array) {\r\n        throw new Error(\"check.array is null\");\r\n    }\r\n    base.array[ROOT_ID] = 1;\r\n    check.array[ROOT_ID] = ROOT_ID;\r\n\r\n    // init BASE\r\n    initBase(base.array, ROOT_ID + 1, base.array.length);\r\n\r\n    // init CHECK\r\n    initCheck(check.array, ROOT_ID + 1, check.array.length);\r\n\r\n    return {\r\n        getBaseBuffer: () => {\r\n            return base.array;\r\n        },\r\n        getCheckBuffer: () => {\r\n            return check.array;\r\n        },\r\n        loadBaseBuffer: (base_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n            base.array = base_buffer;\r\n            return this;\r\n        },\r\n        loadCheckBuffer: (check_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n            check.array = check_buffer;\r\n            return this;\r\n        },\r\n        size: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            return Math.max(base.array.length, check.array.length);\r\n        },\r\n        getBase: (index: number) => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (base.array.length - 1 < index) {\r\n                return - index + 1;\r\n                // realloc(index);\r\n            }\r\n            // if (!Number.isFinite(base.array[index])) {\r\n            //     console.log('getBase:' + index);\r\n            //     throw 'getBase' + index;\r\n            // }\r\n            return base.array[index];\r\n        },\r\n        getCheck: (index: number) => {\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            if (check.array.length - 1 < index) {\r\n                return - index - 1;\r\n                // realloc(index);\r\n            }\r\n            // if (!Number.isFinite(check.array[index])) {\r\n            //     console.log('getCheck:' + index);\r\n            //     throw 'getCheck' + index;\r\n            // }\r\n            return check.array[index];\r\n        },\r\n        setBase: (index: number, base_value: number) => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (base.array.length - 1 < index) {\r\n                realloc(index);\r\n            }\r\n            base.array[index] = base_value;\r\n        },\r\n        setCheck: (index: number, check_value: number) => {\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            if (check.array.length - 1 < index) {\r\n                realloc(index);\r\n            }\r\n            check.array[index] = check_value;\r\n        },\r\n        setFirstUnusedNode: (index: number) => {\r\n            // if (!Number.isFinite(index)) {\r\n            //     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\r\n            // }\r\n            first_unused_node = index;\r\n        },\r\n        getFirstUnusedNode: function () {\r\n            // if (!Number.isFinite(first_unused_node)) {\r\n            //     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\r\n            // }\r\n            return first_unused_node;\r\n        },\r\n        shrink: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            let last_index = Math.max(base.array.length, check.array.length); - 1;\r\n            while (true) {\r\n                if (0 <= check.array[last_index]) {\r\n                    break;\r\n                }\r\n                last_index--;\r\n            }\r\n            base.array = base.array.subarray(0, last_index + 2);   // keep last unused node\r\n            check.array = check.array.subarray(0, last_index + 2); // keep last unused node\r\n        },\r\n        calc: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            let unused_count = 0;\r\n            const size = check.array.length;\r\n            for (let i = 0; i < size; i++) {\r\n                if (check.array[i] < 0) {\r\n                    unused_count++;\r\n                }\r\n            }\r\n            return {\r\n                all: size,\r\n                unused: unused_count,\r\n                efficiency: (size - unused_count) / size\r\n            };\r\n        },\r\n        dump: () => {\r\n            // for debug\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n\r\n            let dump_base = \"\";\r\n            let dump_check = \"\";\r\n\r\n            for (const data of base.array) {\r\n                dump_base = dump_base + \" \" + data;\r\n            }\r\n            for (const data of check.array) {\r\n                dump_check = dump_check + \" \" + data;\r\n            }\r\n            console.log(\"base:\" + dump_base);\r\n            console.log(\"chck:\" + dump_check);\r\n\r\n            return \"base:\" + dump_base + \" chck:\" + dump_check;\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Factory method of double array\r\n */\r\nclass DoubleArrayBuilder {\r\n    bc: ReturnType<typeof newBC>;\r\n    keys: { k: string, v: number }[]\r\n    constructor(initial_size: number = 1024) {\r\n        this.bc = newBC(initial_size);  // BASE and CHECK\r\n        this.keys = [];\r\n    }\r\n\r\n    /**\r\n    * Append a key to initialize set\r\n    * (This method should be called by dictionary ordered key)\r\n    *\r\n    * @param {String} key\r\n    * @param {Number} value Integer value from 0 to max signed integer number - 1\r\n    */\r\n    append(key: string, record: number) {\r\n        this.keys.push({ k: key, v: record });\r\n        return this;\r\n    };\r\n\r\n    /**\r\n    * Build double array for given keys\r\n    *\r\n    * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\r\n    * 'k' is a key string, 'v' is a record assigned to that key.\r\n    * @return {DoubleArray} Compiled double array\r\n    */\r\n    build(keys: { k: string, v: number }[] = this.keys, sorted: boolean = false) {\r\n        if (keys == null) {\r\n            return new DoubleArray(this.bc);\r\n        }\r\n        // Convert key string to ArrayBuffer\r\n        let buff_keys: { k: any; v: number; }[] | null = keys.map((k) => {\r\n            return {\r\n                k: stringToUtf8Bytes(k.k + TERM_CHAR),\r\n                v: k.v\r\n            };\r\n        });\r\n\r\n        // Sort keys by byte order\r\n        if (sorted) {\r\n            this.keys = buff_keys;\r\n        } else {\r\n            this.keys = buff_keys.sort((k1, k2) => {\r\n                const b1 = k1.k;\r\n                const b2 = k2.k;\r\n                const min_length = Math.min(b1.length, b2.length);\r\n                for (let pos = 0; pos < min_length; pos++) {\r\n                    if (b1[pos] === b2[pos]) {\r\n                        continue;\r\n                    }\r\n                    return b1[pos] - b2[pos];\r\n                }\r\n                return b1.length - b2.length;\r\n            });\r\n        }\r\n\r\n        buff_keys = null;  // explicit GC\r\n\r\n        this._build(ROOT_ID, 0, 0, this.keys.length);\r\n        return new DoubleArray(this.bc);\r\n    };\r\n\r\n    /**\r\n    * Append nodes to BASE and CHECK array recursively\r\n    */\r\n    _build(parent_index: number, position: number, start: number, length: number) {\r\n        const children_info = this.getChildrenInfo(position, start, length);\r\n        const _base = this.findAllocatableBase(children_info);\r\n\r\n        this.setBC(parent_index, children_info, _base);\r\n\r\n        let i = 0\r\n        for (const child_code of children_info) {\r\n            if (child_code === TERM_CODE) {\r\n                continue;\r\n            }\r\n            const child_start = children_info[i + 1];\r\n            const child_len = children_info[i + 2];\r\n            const child_index = _base + child_code;\r\n            this._build(child_index, position + 1, child_start, child_len);\r\n            i = i + 1;\r\n        }\r\n    };\r\n\r\n    getChildrenInfo(position: number, start: number, length: number) {\r\n        let current_char = this.keys[start].k[position];\r\n        let children_info = new Int32Array(length * 3);\r\n        let i = 0;\r\n\r\n        children_info[i++] = parseInt(current_char);  // char (current)\r\n        children_info[i++] = start;         // start index (current)\r\n\r\n        let next_pos = start;\r\n        let start_pos = start;\r\n        for (; next_pos < start + length; next_pos++) {\r\n            const next_char = this.keys[next_pos].k[position];\r\n            if (current_char !== next_char) {\r\n                children_info[i++] = next_pos - start_pos;  // length (current)\r\n\r\n                children_info[i++] = parseInt(next_char);             // char (next)\r\n                children_info[i++] = next_pos;              // start index (next)\r\n                current_char = next_char;\r\n                start_pos = next_pos;\r\n            }\r\n        }\r\n        children_info[i++] = next_pos - start_pos;\r\n        children_info = children_info.subarray(0, i);\r\n\r\n        return children_info;\r\n    };\r\n\r\n    setBC(parent_id: number, children_info: Int32Array, _base: number) {\r\n        const bc = this.bc;\r\n        bc.setBase(parent_id, _base);  // Update BASE of parent node\r\n        let i = 0;\r\n        for (const code of children_info) {\r\n            const child_id = _base + code;\r\n            // Update linked list of unused nodes\r\n\r\n            // Assertion\r\n            // if (child_id < 0) {\r\n            //     throw 'assertion error: child_id is negative'\r\n            // }\r\n\r\n            const prev_unused_id = - bc.getBase(child_id);\r\n            const next_unused_id = - bc.getCheck(child_id);\r\n            // if (prev_unused_id < 0) {\r\n            //     throw 'assertion error: setBC'\r\n            // }\r\n            // if (next_unused_id < 0) {\r\n            //     throw 'assertion error: setBC'\r\n            // }\r\n            if (child_id !== bc.getFirstUnusedNode()) {\r\n                bc.setCheck(prev_unused_id, - next_unused_id);\r\n            } else {\r\n                // Update first_unused_node\r\n                bc.setFirstUnusedNode(next_unused_id);\r\n            }\r\n            bc.setBase(next_unused_id, - prev_unused_id);\r\n\r\n            const check = parent_id;         // CHECK is parent node index\r\n            bc.setCheck(child_id, check);  // Update CHECK of child node\r\n\r\n            // Update record\r\n            if (code === TERM_CODE) {\r\n                const start_pos = children_info[i + 1];\r\n                // var len = children_info[i + 2];\r\n                // if (len != 1) {\r\n                //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\r\n                // }\r\n                let value = this.keys[start_pos].v;\r\n\r\n                if (value == null) {\r\n                    value = 0;\r\n                }\r\n\r\n                const base = - value - 1;       // BASE is inverted record value\r\n                bc.setBase(child_id, base);  // Update BASE of child(leaf) node\r\n            }\r\n            i = i + 1;\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Find BASE value that all children are allocatable in double array's region\r\n    */\r\n    findAllocatableBase(children_info: Int32Array) {\r\n        const bc = this.bc;\r\n        // Assertion: keys are sorted by byte order\r\n        // var c = -1;\r\n        // for (var i = 0; i < children_info.length; i = i + 3) {\r\n        //     if (children_info[i] < c) {\r\n        //         throw 'assertion error: not sort key'\r\n        //     }\r\n        //     c = children_info[i];\r\n        // }\r\n\r\n        // iterate linked list of unused nodes\r\n        let _base: number;\r\n        let curr = bc.getFirstUnusedNode();  // current index\r\n        // if (curr < 0) {\r\n        //     throw 'assertion error: getFirstUnusedNode returns negative value'\r\n        // }\r\n\r\n        while (true) {\r\n            _base = curr - children_info[0];\r\n            if (_base < 0) {\r\n                curr = - bc.getCheck(curr);  // next\r\n\r\n                // if (curr < 0) {\r\n                //     throw 'assertion error: getCheck returns negative value'\r\n                // }\r\n\r\n                continue;\r\n            }\r\n\r\n            let empty_area_found = true;\r\n            for (const code of children_info) {\r\n                const candidate_id = _base + code;\r\n                if (!this.isUnusedNode(candidate_id)) {\r\n                    // candidate_id is used node\r\n                    // next\r\n                    curr = - bc.getCheck(curr);\r\n                    // if (curr < 0) {\r\n                    //     throw 'assertion error: getCheck returns negative value'\r\n                    // }\r\n                    empty_area_found = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (empty_area_found) {\r\n                // Area is free\r\n                return _base;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Check this double array index is unused or not\r\n    */\r\n    isUnusedNode(index: number) {\r\n        const bc = this.bc;\r\n        const check = bc.getCheck(index);\r\n\r\n        // if (index < 0) {\r\n        //     throw 'assertion error: isUnusedNode index:' + index;\r\n        // }\r\n\r\n        if (index === ROOT_ID) {\r\n            // root node\r\n            return false;\r\n        }\r\n        if (check < 0) {\r\n            // unused\r\n            return true;\r\n        }\r\n\r\n        // used node (incl. leaf)\r\n        return false;\r\n    };\r\n}\r\n\r\n/**\r\n* Factory method of double array\r\n*/\r\nclass DoubleArray {\r\n    bc: ReturnType<typeof newBC>;\r\n    constructor(bc: ReturnType<typeof newBC>) {\r\n        this.bc = bc;  // BASE and CHECK\r\n        this.bc.shrink();\r\n    }\r\n\r\n    /**\r\n     * Look up a given key in this trie\r\n     *\r\n     * @param {String} key\r\n     * @return {Boolean} True if this trie contains a given key\r\n     */\r\n    contain(key: string) {\r\n        const bc = this.bc;\r\n        key += TERM_CHAR;\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child === NOT_FOUND) {\r\n                return false;\r\n            }\r\n\r\n            if (bc.getBase(child) <= 0) {\r\n                // leaf node\r\n                return true;\r\n            } else {\r\n                // not leaf\r\n                parent = child;\r\n                continue;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n    * Look up a given key in this trie\r\n    *\r\n    * @param {String} key\r\n    * @return {Number} Record value assgned to this key, -1 if this key does not contain\r\n    */\r\n    lookup(key: string) {\r\n        key += TERM_CHAR;\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child === NOT_FOUND) {\r\n                return NOT_FOUND;\r\n            }\r\n            parent = child;\r\n        }\r\n        const base = this.bc.getBase(child);\r\n        if (base <= 0) {\r\n            // leaf node\r\n            return - base - 1;\r\n        } else {\r\n            // not leaf\r\n            return NOT_FOUND;\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n    * Common prefix search\r\n    *\r\n    * @param {String} key\r\n    * @return {Array} Each result object has 'k' and 'v' (key and record,\r\n    * respectively) properties assigned to matched string\r\n    */\r\n    commonPrefixSearch(key: string) {\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        const result = [];\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        let i = 0\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child !== NOT_FOUND) {\r\n                parent = child;\r\n                // look forward by terminal character code to check this node is a leaf or not\r\n                const grand_child = this.traverse(child, TERM_CODE);\r\n                if (grand_child !== NOT_FOUND) {\r\n                    const base = this.bc.getBase(grand_child);\r\n                    const r: { k: string, v: number } = { k: '', v: -1 };\r\n                    if (base <= 0) {\r\n                        // If child is a leaf node, add record to result\r\n                        r.v = - base - 1;\r\n                    }\r\n                    // If child is a leaf node, add word to result\r\n                    r.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\r\n                    result.push(r);\r\n                }\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n            i = i + 1;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    traverse(parent: number, code: number) {\r\n        const child = this.bc.getBase(parent) + code;\r\n        if (this.bc.getCheck(child) === parent) {\r\n            return child;\r\n        } else {\r\n            return NOT_FOUND;\r\n        }\r\n    };\r\n\r\n    size() {\r\n        return this.bc.size();\r\n    };\r\n\r\n    calc() {\r\n        return this.bc.calc();\r\n    };\r\n\r\n    dump() {\r\n        return this.bc.dump();\r\n    };\r\n}\r\n\r\nconst doublearray = {\r\n    builder: (initial_size: number = 1024) => {\r\n        return new DoubleArrayBuilder(initial_size);\r\n    },\r\n    load: (base_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array, check_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n        const bc = newBC(0);\r\n        bc.loadBaseBuffer(base_buffer);\r\n        bc.loadCheckBuffer(check_buffer);\r\n        return new DoubleArray(bc);\r\n    }\r\n};\r\n\r\nexport { DoubleArrayBuilder, DoubleArray };\r\n\r\nexport default doublearray;\r\n"
  ],
  "mappings": "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",
  "debugId": "6AC6408EA951663564756E2164756E21",
  "names": []
}