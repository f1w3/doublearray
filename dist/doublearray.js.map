{
  "version": 3,
  "sources": ["..\\doublearray.ts"],
  "sourcesContent": [
    "// Copyright (c) 2014 Takuya Asano All Rights Reserved.\r\n\r\n/*\r\n *\r\n * rewrite by @f1w3_ | 2024\r\n * All rights reserved by Takuya Asano.\r\n * See above for more information.\r\n *  \r\n */\r\n\r\n\"use strict\";\r\n\r\nconst TERM_CHAR = \"\\u0000\"; // terminal character\r\nconst TERM_CODE = 0;        // terminal character code\r\nconst ROOT_ID = 0;          // index of root node\r\nconst NOT_FOUND = -1;       // traverse() returns if no nodes found\r\nconst BASE_SIGNED = true;\r\nconst CHECK_SIGNED = true;\r\nconst BASE_BYTES = 4;\r\nconst CHECK_BYTES = 4;\r\nconst MEMORY_EXPAND_RATIO = 2;\r\n\r\n// Array utility functions\r\nconst newArrayBuffer = (signed: boolean, bytes: number, size: number) => {\r\n    if (signed) {\r\n        switch (bytes) {\r\n            case 1:\r\n                return new Int8Array(size);\r\n            case 2:\r\n                return new Int16Array(size);\r\n            case 4:\r\n                return new Int32Array(size);\r\n            default:\r\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\r\n        }\r\n    } else {\r\n        switch (bytes) {\r\n            case 1:\r\n                return new Uint8Array(size);\r\n            case 2:\r\n                return new Uint16Array(size);\r\n            case 4:\r\n                return new Uint32Array(size);\r\n            default:\r\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\r\n        }\r\n    }\r\n};\r\n\r\nconst arrayCopy = (src: Uint8Array, src_offset: number, length: number) => {\r\n    var buffer = new ArrayBuffer(length);\r\n    var dstU8 = new Uint8Array(buffer, 0, length);\r\n    var srcU8 = src.subarray(src_offset, length);\r\n    dstU8.set(srcU8);\r\n    return dstU8;\r\n};\r\n\r\n/**\r\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\r\n *\r\n * @param {String} str UTF-16 string to convert\r\n * @return {Uint8Array | null} Byte sequence encoded by UTF-8\r\n */\r\nconst stringToUtf8Bytes = (str: string): Uint8Array | null => {\r\n    const bytes = new Uint8Array(str.length * 4);\r\n    let j = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let unicode_code = str.charCodeAt(i);\r\n        if (unicode_code >= 0xD800 && unicode_code <= 0xDBFF) {\r\n            // surrogate pair\r\n            if (i + 1 < str.length) {\r\n                const lower = str.charCodeAt(++i);\r\n                if (lower >= 0xDC00 && lower <= 0xDFFF) {\r\n                    unicode_code = ((unicode_code - 0xD800) << 10) + (lower - 0xDC00) + 0x10000;\r\n                } else {\r\n                    return null; // malformed surrogate pair\r\n                }\r\n            } else {\r\n                return null; // malformed surrogate pair at end of string\r\n            }\r\n        }\r\n\r\n        if (unicode_code < 0x80) {\r\n            bytes[j++] = unicode_code;\r\n        } else if (unicode_code < 0x800) {\r\n            bytes[j++] = 0xC0 | (unicode_code >>> 6);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else if (unicode_code < 0x10000) {\r\n            bytes[j++] = 0xE0 | (unicode_code >>> 12);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 6) & 0x3F);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else if (unicode_code < 0x110000) {\r\n            bytes[j++] = 0xF0 | (unicode_code >>> 18);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 12) & 0x3F);\r\n            bytes[j++] = 0x80 | ((unicode_code >>> 6) & 0x3F);\r\n            bytes[j++] = 0x80 | (unicode_code & 0x3F);\r\n        } else {\r\n            return null; // malformed UCS4 code\r\n        }\r\n    }\r\n\r\n    return bytes.subarray(0, j);\r\n};\r\n\r\n/**\r\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\r\n *\r\n * @param {Uint8Array} bytes UTF-8 byte sequence to convert\r\n * @return {String} String encoded by UTF-16\r\n */\r\nconst utf8BytesToString = (bytes: Uint8Array): string => {\r\n    const strArray = [];\r\n    let i = 0;\r\n\r\n    while (i < bytes.length) {\r\n        const b1 = bytes[i++];\r\n        let code;\r\n\r\n        if (b1 < 0x80) {\r\n            // 1 byte\r\n            code = b1;\r\n        } else if ((b1 >> 5) === 0x06) {\r\n            // 2 bytes\r\n            const b2 = bytes[i++];\r\n            code = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\r\n        } else if ((b1 >> 4) === 0x0e) {\r\n            // 3 bytes\r\n            const b2 = bytes[i++];\r\n            const b3 = bytes[i++];\r\n            code = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\r\n        } else {\r\n            // 4 bytes\r\n            const b2 = bytes[i++];\r\n            const b3 = bytes[i++];\r\n            const b4 = bytes[i++];\r\n            code = ((b1 & 0x07) << 18) | ((b2 & 0x3f) << 12) | ((b3 & 0x3f) << 6) | (b4 & 0x3f);\r\n        }\r\n\r\n        if (code < 0x10000) {\r\n            strArray.push(String.fromCharCode(code));\r\n        } else {\r\n            // surrogate pair\r\n            code -= 0x10000;\r\n            strArray.push(String.fromCharCode(0xD800 | (code >> 10)));\r\n            strArray.push(String.fromCharCode(0xDC00 | (code & 0x3FF)));\r\n        }\r\n    }\r\n\r\n    return strArray.join('');\r\n};\r\n\r\ntype ArrayBuffer = Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array;\r\n\r\ntype BaseCheck = {\r\n    signed: boolean,\r\n    bytes: number,\r\n    array: ArrayBuffer | null\r\n};\r\n\r\nconst newBC = (initial_size: number = 1024) => {\r\n    const initBase = (_base: ArrayBuffer, start: number, end: number) => {  // 'end' index does not include\r\n        if (!check.array) {\r\n            throw new Error(\"check array is not initialized\");\r\n        }\r\n        for (let i = start; i < end; i++) {\r\n            _base[i] = - i + 1;  // inversed previous empty node index\r\n        }\r\n        if (0 < check.array[check.array.length - 1]) {\r\n            let last_used_id = check.array.length - 2;\r\n            while (0 < check.array[last_used_id]) {\r\n                last_used_id--;\r\n            }\r\n            _base[start] = - last_used_id;\r\n        }\r\n    };\r\n\r\n    const initCheck = (_check: ArrayBuffer, start: number, end: number) => {\r\n        for (let i = start; i < end; i++) {\r\n            _check[i] = - i - 1;  // inversed next empty node index\r\n        }\r\n    };\r\n\r\n    const realloc = (min_size: number) => {\r\n        // expand arrays size by given ratio\r\n        const new_size = min_size * MEMORY_EXPAND_RATIO;\r\n        // console.log('re-allocate memory to ' + new_size);\r\n\r\n        const base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\r\n        if (!base.array) throw new Error('realloc failed. base.array is null');\r\n        initBase(base_new_array, base.array.length, new_size);  // init BASE in new range\r\n        base_new_array.set(base.array);\r\n        base.array = null;  // explicit GC\r\n        base.array = base_new_array;\r\n\r\n        const check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\r\n        if (!check.array) throw new Error('realloc failed. check.array is null');\r\n        initCheck(check_new_array, check.array.length, new_size);  // init CHECK in new range\r\n        check_new_array.set(check.array);\r\n        check.array = null;  // explicit GC\r\n        check.array = check_new_array;\r\n    };\r\n\r\n    let first_unused_node = ROOT_ID + 1;\r\n\r\n    const base: BaseCheck = {\r\n        signed: BASE_SIGNED,\r\n        bytes: BASE_BYTES,\r\n        array: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size)\r\n    };\r\n\r\n    const check: BaseCheck = {\r\n        signed: CHECK_SIGNED,\r\n        bytes: CHECK_BYTES,\r\n        array: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size)\r\n    };\r\n\r\n    // init root node\r\n    if (!base.array) {\r\n        throw new Error(\"base.array is null\");\r\n    }\r\n    if (!check.array) {\r\n        throw new Error(\"check.array is null\");\r\n    }\r\n    base.array[ROOT_ID] = 1;\r\n    check.array[ROOT_ID] = ROOT_ID;\r\n\r\n    // init BASE\r\n    initBase(base.array, ROOT_ID + 1, base.array.length);\r\n\r\n    // init CHECK\r\n    initCheck(check.array, ROOT_ID + 1, check.array.length);\r\n\r\n    return {\r\n        getBaseBuffer: () => {\r\n            return base.array;\r\n        },\r\n        getCheckBuffer: () => {\r\n            return check.array;\r\n        },\r\n        loadBaseBuffer: (base_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n            base.array = base_buffer;\r\n            return this;\r\n        },\r\n        loadCheckBuffer: (check_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n            check.array = check_buffer;\r\n            return this;\r\n        },\r\n        size: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            return Math.max(base.array.length, check.array.length);\r\n        },\r\n        getBase: (index: number) => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (base.array.length - 1 < index) {\r\n                return - index + 1;\r\n                // realloc(index);\r\n            }\r\n            // if (!Number.isFinite(base.array[index])) {\r\n            //     console.log('getBase:' + index);\r\n            //     throw 'getBase' + index;\r\n            // }\r\n            return base.array[index];\r\n        },\r\n        getCheck: (index: number) => {\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            if (check.array.length - 1 < index) {\r\n                return - index - 1;\r\n                // realloc(index);\r\n            }\r\n            // if (!Number.isFinite(check.array[index])) {\r\n            //     console.log('getCheck:' + index);\r\n            //     throw 'getCheck' + index;\r\n            // }\r\n            return check.array[index];\r\n        },\r\n        setBase: (index: number, base_value: number) => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (base.array.length - 1 < index) {\r\n                realloc(index);\r\n            }\r\n            base.array[index] = base_value;\r\n        },\r\n        setCheck: (index: number, check_value: number) => {\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            if (check.array.length - 1 < index) {\r\n                realloc(index);\r\n            }\r\n            check.array[index] = check_value;\r\n        },\r\n        setFirstUnusedNode: (index: number) => {\r\n            // if (!Number.isFinite(index)) {\r\n            //     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\r\n            // }\r\n            first_unused_node = index;\r\n        },\r\n        getFirstUnusedNode: function () {\r\n            // if (!Number.isFinite(first_unused_node)) {\r\n            //     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\r\n            // }\r\n            return first_unused_node;\r\n        },\r\n        shrink: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            let last_index = Math.max(base.array.length, check.array.length); - 1;\r\n            while (true) {\r\n                if (0 <= check.array[last_index]) {\r\n                    break;\r\n                }\r\n                last_index--;\r\n            }\r\n            base.array = base.array.subarray(0, last_index + 2);   // keep last unused node\r\n            check.array = check.array.subarray(0, last_index + 2); // keep last unused node\r\n        },\r\n        calc: () => {\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n            let unused_count = 0;\r\n            const size = check.array.length;\r\n            for (let i = 0; i < size; i++) {\r\n                if (check.array[i] < 0) {\r\n                    unused_count++;\r\n                }\r\n            }\r\n            return {\r\n                all: size,\r\n                unused: unused_count,\r\n                efficiency: (size - unused_count) / size\r\n            };\r\n        },\r\n        dump: () => {\r\n            // for debug\r\n            if (!base.array) {\r\n                throw new Error(\"base.array is null\");\r\n            }\r\n            if (!check.array) {\r\n                throw new Error(\"check.array is null\");\r\n            }\r\n\r\n            let dump_base = \"\";\r\n            let dump_check = \"\";\r\n\r\n            for (const data of base.array) {\r\n                dump_base = dump_base + \" \" + data;\r\n            }\r\n            for (const data of check.array) {\r\n                dump_check = dump_check + \" \" + data;\r\n            }\r\n            console.log(\"base:\" + dump_base);\r\n            console.log(\"chck:\" + dump_check);\r\n\r\n            return \"base:\" + dump_base + \" chck:\" + dump_check;\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Factory method of double array\r\n */\r\nclass DoubleArrayBuilder {\r\n    bc: ReturnType<typeof newBC>;\r\n    keys: { k: string, v: number }[]\r\n    constructor(initial_size: number = 1024) {\r\n        this.bc = newBC(initial_size);  // BASE and CHECK\r\n        this.keys = [];\r\n    }\r\n\r\n    /**\r\n    * Append a key to initialize set\r\n    * (This method should be called by dictionary ordered key)\r\n    *\r\n    * @param {String} key\r\n    * @param {Number} value Integer value from 0 to max signed integer number - 1\r\n    */\r\n    append(key: string, record: number) {\r\n        this.keys.push({ k: key, v: record });\r\n        return this;\r\n    };\r\n\r\n    /**\r\n    * Build double array for given keys\r\n    *\r\n    * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\r\n    * 'k' is a key string, 'v' is a record assigned to that key.\r\n    * @return {DoubleArray} Compiled double array\r\n    */\r\n    build(keys: { k: string, v: number }[] = this.keys, sorted: boolean = false) {\r\n        if (keys == null) {\r\n            return new DoubleArray(this.bc);\r\n        }\r\n        // Convert key string to ArrayBuffer\r\n        let buff_keys: { k: any; v: number; }[] | null = keys.map((k) => {\r\n            return {\r\n                k: stringToUtf8Bytes(k.k + TERM_CHAR),\r\n                v: k.v\r\n            };\r\n        });\r\n\r\n        // Sort keys by byte order\r\n        if (sorted) {\r\n            this.keys = buff_keys;\r\n        } else {\r\n            this.keys = buff_keys.sort((k1, k2) => {\r\n                const b1 = k1.k;\r\n                const b2 = k2.k;\r\n                const min_length = Math.min(b1.length, b2.length);\r\n                for (let pos = 0; pos < min_length; pos++) {\r\n                    if (b1[pos] === b2[pos]) {\r\n                        continue;\r\n                    }\r\n                    return b1[pos] - b2[pos];\r\n                }\r\n                return b1.length - b2.length;\r\n            });\r\n        }\r\n\r\n        buff_keys = null;  // explicit GC\r\n\r\n        this._build(ROOT_ID, 0, 0, this.keys.length);\r\n        return new DoubleArray(this.bc);\r\n    };\r\n\r\n    /**\r\n    * Append nodes to BASE and CHECK array recursively\r\n    */\r\n    _build(parent_index: number, position: number, start: number, length: number) {\r\n        const children_info = this.getChildrenInfo(position, start, length);\r\n        const _base = this.findAllocatableBase(children_info);\r\n\r\n        this.setBC(parent_index, children_info, _base);\r\n\r\n        let i = 0\r\n        for (const child_code of children_info) {\r\n            if (child_code === TERM_CODE) {\r\n                continue;\r\n            }\r\n            const child_start = children_info[i + 1];\r\n            const child_len = children_info[i + 2];\r\n            const child_index = _base + child_code;\r\n            this._build(child_index, position + 1, child_start, child_len);\r\n            i = i + 1;\r\n        }\r\n    };\r\n\r\n    getChildrenInfo(position: number, start: number, length: number) {\r\n        let current_char = this.keys[start].k[position];\r\n        let children_info = new Int32Array(length * 3);\r\n        let i = 0;\r\n\r\n        children_info[i++] = parseInt(current_char);  // char (current)\r\n        children_info[i++] = start;         // start index (current)\r\n\r\n        let next_pos = start;\r\n        let start_pos = start;\r\n        for (; next_pos < start + length; next_pos++) {\r\n            const next_char = this.keys[next_pos].k[position];\r\n            if (current_char !== next_char) {\r\n                children_info[i++] = next_pos - start_pos;  // length (current)\r\n\r\n                children_info[i++] = parseInt(next_char);             // char (next)\r\n                children_info[i++] = next_pos;              // start index (next)\r\n                current_char = next_char;\r\n                start_pos = next_pos;\r\n            }\r\n        }\r\n        children_info[i++] = next_pos - start_pos;\r\n        children_info = children_info.subarray(0, i);\r\n\r\n        return children_info;\r\n    };\r\n\r\n    setBC(parent_id: number, children_info: Int32Array, _base: number) {\r\n        const bc = this.bc;\r\n        bc.setBase(parent_id, _base);  // Update BASE of parent node\r\n        let i = 0;\r\n        for (const code of children_info) {\r\n            const child_id = _base + code;\r\n            // Update linked list of unused nodes\r\n\r\n            // Assertion\r\n            // if (child_id < 0) {\r\n            //     throw 'assertion error: child_id is negative'\r\n            // }\r\n\r\n            const prev_unused_id = - bc.getBase(child_id);\r\n            const next_unused_id = - bc.getCheck(child_id);\r\n            // if (prev_unused_id < 0) {\r\n            //     throw 'assertion error: setBC'\r\n            // }\r\n            // if (next_unused_id < 0) {\r\n            //     throw 'assertion error: setBC'\r\n            // }\r\n            if (child_id !== bc.getFirstUnusedNode()) {\r\n                bc.setCheck(prev_unused_id, - next_unused_id);\r\n            } else {\r\n                // Update first_unused_node\r\n                bc.setFirstUnusedNode(next_unused_id);\r\n            }\r\n            bc.setBase(next_unused_id, - prev_unused_id);\r\n\r\n            const check = parent_id;         // CHECK is parent node index\r\n            bc.setCheck(child_id, check);  // Update CHECK of child node\r\n\r\n            // Update record\r\n            if (code === TERM_CODE) {\r\n                const start_pos = children_info[i + 1];\r\n                // var len = children_info[i + 2];\r\n                // if (len != 1) {\r\n                //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\r\n                // }\r\n                let value = this.keys[start_pos].v;\r\n\r\n                if (value == null) {\r\n                    value = 0;\r\n                }\r\n\r\n                const base = - value - 1;       // BASE is inverted record value\r\n                bc.setBase(child_id, base);  // Update BASE of child(leaf) node\r\n            }\r\n            i = i + 1;\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Find BASE value that all children are allocatable in double array's region\r\n    */\r\n    findAllocatableBase(children_info: Int32Array) {\r\n        const bc = this.bc;\r\n        // Assertion: keys are sorted by byte order\r\n        // var c = -1;\r\n        // for (var i = 0; i < children_info.length; i = i + 3) {\r\n        //     if (children_info[i] < c) {\r\n        //         throw 'assertion error: not sort key'\r\n        //     }\r\n        //     c = children_info[i];\r\n        // }\r\n\r\n        // iterate linked list of unused nodes\r\n        let _base: number;\r\n        let curr = bc.getFirstUnusedNode();  // current index\r\n        // if (curr < 0) {\r\n        //     throw 'assertion error: getFirstUnusedNode returns negative value'\r\n        // }\r\n\r\n        while (true) {\r\n            _base = curr - children_info[0];\r\n            if (_base < 0) {\r\n                curr = - bc.getCheck(curr);  // next\r\n\r\n                // if (curr < 0) {\r\n                //     throw 'assertion error: getCheck returns negative value'\r\n                // }\r\n\r\n                continue;\r\n            }\r\n\r\n            let empty_area_found = true;\r\n            for (const code of children_info) {\r\n                const candidate_id = _base + code;\r\n                if (!this.isUnusedNode(candidate_id)) {\r\n                    // candidate_id is used node\r\n                    // next\r\n                    curr = - bc.getCheck(curr);\r\n                    // if (curr < 0) {\r\n                    //     throw 'assertion error: getCheck returns negative value'\r\n                    // }\r\n                    empty_area_found = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (empty_area_found) {\r\n                // Area is free\r\n                return _base;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Check this double array index is unused or not\r\n    */\r\n    isUnusedNode(index: number) {\r\n        const bc = this.bc;\r\n        const check = bc.getCheck(index);\r\n\r\n        // if (index < 0) {\r\n        //     throw 'assertion error: isUnusedNode index:' + index;\r\n        // }\r\n\r\n        if (index === ROOT_ID) {\r\n            // root node\r\n            return false;\r\n        }\r\n        if (check < 0) {\r\n            // unused\r\n            return true;\r\n        }\r\n\r\n        // used node (incl. leaf)\r\n        return false;\r\n    };\r\n}\r\n\r\n/**\r\n* Factory method of double array\r\n*/\r\nclass DoubleArray {\r\n    bc: ReturnType<typeof newBC>;\r\n    constructor(bc: ReturnType<typeof newBC>) {\r\n        this.bc = bc;  // BASE and CHECK\r\n        this.bc.shrink();\r\n    }\r\n\r\n    /**\r\n     * Look up a given key in this trie\r\n     *\r\n     * @param {String} key\r\n     * @return {Boolean} True if this trie contains a given key\r\n     */\r\n    contain(key: string) {\r\n        const bc = this.bc;\r\n        key += TERM_CHAR;\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child === NOT_FOUND) {\r\n                return false;\r\n            }\r\n\r\n            if (bc.getBase(child) <= 0) {\r\n                // leaf node\r\n                return true;\r\n            } else {\r\n                // not leaf\r\n                parent = child;\r\n                continue;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n    * Look up a given key in this trie\r\n    *\r\n    * @param {String} key\r\n    * @return {Number} Record value assgned to this key, -1 if this key does not contain\r\n    */\r\n    lookup(key: string) {\r\n        key += TERM_CHAR;\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child === NOT_FOUND) {\r\n                return NOT_FOUND;\r\n            }\r\n            parent = child;\r\n        }\r\n        const base = this.bc.getBase(child);\r\n        if (base <= 0) {\r\n            // leaf node\r\n            return - base - 1;\r\n        } else {\r\n            // not leaf\r\n            return NOT_FOUND;\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n    * Common prefix search\r\n    *\r\n    * @param {String} key\r\n    * @return {Array} Each result object has 'k' and 'v' (key and record,\r\n    * respectively) properties assigned to matched string\r\n    */\r\n    commonPrefixSearch(key: string) {\r\n        const buffer = stringToUtf8Bytes(key);\r\n        if (!buffer) {\r\n            throw new Error('invalid key');\r\n        }\r\n        const result = [];\r\n        let parent = ROOT_ID;\r\n        let child = NOT_FOUND;\r\n        let i = 0\r\n        for (const code of buffer) {\r\n            child = this.traverse(parent, code);\r\n            if (child !== NOT_FOUND) {\r\n                parent = child;\r\n                // look forward by terminal character code to check this node is a leaf or not\r\n                const grand_child = this.traverse(child, TERM_CODE);\r\n                if (grand_child !== NOT_FOUND) {\r\n                    const base = this.bc.getBase(grand_child);\r\n                    const r: { k: string, v: number } = { k: '', v: -1 };\r\n                    if (base <= 0) {\r\n                        // If child is a leaf node, add record to result\r\n                        r.v = - base - 1;\r\n                    }\r\n                    // If child is a leaf node, add word to result\r\n                    r.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\r\n                    result.push(r);\r\n                }\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n            i = i + 1;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    traverse(parent: number, code: number) {\r\n        const child = this.bc.getBase(parent) + code;\r\n        if (this.bc.getCheck(child) === parent) {\r\n            return child;\r\n        } else {\r\n            return NOT_FOUND;\r\n        }\r\n    };\r\n\r\n    size() {\r\n        return this.bc.size();\r\n    };\r\n\r\n    calc() {\r\n        return this.bc.calc();\r\n    };\r\n\r\n    dump() {\r\n        return this.bc.dump();\r\n    };\r\n}\r\n\r\nconst doublearray = {\r\n    builder: (initial_size: number = 1024) => {\r\n        return new DoubleArrayBuilder(initial_size);\r\n    },\r\n    load: (base_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array, check_buffer: Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array) => {\r\n        const bc = newBC(0);\r\n        bc.loadBaseBuffer(base_buffer);\r\n        bc.loadCheckBuffer(check_buffer);\r\n        return new DoubleArray(bc);\r\n    }\r\n};\r\n\r\nexport { DoubleArrayBuilder, DoubleArray };\r\n\r\nexport default doublearray;\r\n"
  ],
  "mappings": "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",
  "debugId": "9A0C3E81C287D05864756E2164756E21",
  "names": []
}